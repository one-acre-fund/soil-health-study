rename(ssn = lab.ssn) %>%
mutate(
idDups = duplicated(id) | duplicated(.[nrow(.):1, "id"])[nrow(.):1],
ssnDups = duplicated(ssn) | duplicated(.[nrow(.):1, "ssn"])[nrow(.):1]
)
pairedSoil <- pairedSoil %>%
setNames(tolower(names(.)))
#table(psi$ssn %in% pairedSoil$ssn) # FALSE  TRUE  41   703
#table(pairedSoil$ssn %in% psi$ssn) # FALSE  TRUE  27   703
pairedSoil <- left_join(pairedSoil, psi, by="ssn") # keeps all paired soil values, no duplicated ids
beanCheck <- bean %>%
filter(!is.na(soil_code)) %>%
mutate(
idDups = duplicated(soil_code) | duplicated(.[nrow(.):1, "soil_code"])[nrow(.):1]
)
beanCheck %>%
filter(idDups==TRUE) %>%
arrange(soil_code) %>%
dplyr::select(district, cell, soil_code)
#vector of duplicated ids in the bean data
idComps <- unique(beanCheck$soil_code[beanCheck$idDups==TRUE])
pairedSoil %>%
filter(id %in% idComps) %>%
arrange(id) %>%
dplyr::select(district, cell, id)
bean <- bean[-which(bean$soil_code==1326301 & bean$cell=="Gahira"),]
py <- bean %>%
filter(!is.na(soil_code)) %>%
mutate(
idDups = duplicated(soil_code) | duplicated(.[nrow(.):1, "soil_code"])[nrow(.):1]
) %>%
filter(idDups==FALSE) %>%
rename(ns = id, # change the bean id to something else,  nonsense
id = soil_code)
loss <- table(py$id %in% pairedSoil$id)[[1]]
#py$id[!py$id %in% pairedSoil$id]
#table(pairedSoil$id %in% py$id)
toJoin <- names(pairedSoil)[c(2:22,25)]
py <- py %>%
inner_join(., pairedSoil[,toJoin], by="id")
py$box_length1 <- ifelse(py$d_box_lenght1!=7 & py$d_box_lenght1!=3, 5, py$d_box_lenght1)
py$box_width1 <- ifelse(py$d_box_width1!=7 & py$d_box_width1!=3, 5, py$d_box_width1)
py$box_length2 <- ifelse(py$d_box_length2!=7 & py$d_box_length2!=3, 5, py$d_box_length2)
py$box_width2 <- ifelse(py$d_box_width2!=7 & py$d_box_width2!=3, 5, py$d_box_width2)
calculateYield <- function(bagA, bagB, lenA, lenB, widthA, widthB, df) {
#convert to numeric
df[,c(bagA, bagB, lenA, lenB, widthA, widthB)] <- sapply(df[,c(bagA, bagB, lenA, lenB, widthA, widthB)], function(x){
as.numeric(as.character(x))
})
# calculate box areas
df$boxAreaA <- df[,lenA] * df[,widthA]
df$boxAreaB <- df[,lenB] * df[,widthB]
df$yieldA <- df[,bagA] / df$boxAreaA
df$yieldB <- df[,bagB] / df$boxAreaB
df$yieldProbsA <- is.na(df$yieldA) | is.infinite(df$yieldA)
df$yieldProbsB <- is.na(df$yieldB) | is.infinite(df$yieldB)
df$yield <- (df[,bagA] + df[,bagB]) / (df$boxAreaA + df$boxAreaB)
df$yield[!df$yieldProbsA & df$yieldProbsB] <-
df$yieldA[!df$yieldProbsA & df$yieldProbsB]
df$yield[!df$yieldProbsB & df$yieldProbsA] <-
df$yieldB[!df$yieldProbsB & df$yieldProbsA]
return(df)
}
py <- calculateYield("box_kg1", "box_kg2", "box_length1", "box_length2", "box_width1", "box_width2", py)
respVar <- c(names(py)[which(names(py)=="ph"): which(names(py)=="x.total.nitrogen")], "yield")
#yr <- py[,names(py) %in% respVar]
py$tha <- py$yield * 10
soilVars <- names(py)[which(names(py)=="ph"):which(names(py)=="x.total.nitrogen")]
keySoilVars <- c("ph", "x.organic.carbon", "x.total.nitrogen", "calcium", "magnesium")
iqr.check <- function(dat, x) {
q1 = summary(dat[,x])[[2]]
q3 = summary(dat[,x])[[5]]
iqr = q3-q1
mark  = ifelse(dat[,x] < (q1 - (1.5*iqr)) | dat[,x] > (q3 + (1.5*iqr)), 1,0)
tab = rbind(
summary(dat[,x]),
summary(dat[mark==0, x])
)
return(tab)
}
soilYTab <- do.call(plyr::rbind.fill, lapply(soilVars, function(y){
#print(y)
res = iqr.check(py, y)
#print(dim(res))
out = data.frame(var=rbind(y, paste(y, ".iqr", sep="")), res)
return(out)
}))
soilYTab[,2:length(soilYTab)] <- sapply(soilYTab[,2:length(soilYTab)], function(x){round(x,2)})
knitr::kable(soilYTab, row.names = F, digits = 3, format = 'markdown')
check.3sd <- function(x) {
x = ifelse(is.infinite(x), NA, x)
mean = mean(x, na.rm=T)
sd = sd(x, na.rm=T)
mark = ifelse(x>(mean + (3*sd)) |
x<(mean - (3*sd)), NA, x)
return(mark)
}
sdSoilVals.py <- py %>%
dplyr::select(one_of(soilVars))
sdCheck.py <- as.data.frame(apply(sdSoilVals.py, 2, function(x){
return(check.3sd(x))
}))
names(py)[which(names(py)=="ph"):which(names(py)=="x.total.nitrogen")] <- paste0(names(py)[which(names(py)=="ph"):which(names(py)=="x.total.nitrogen")], ".raw")
py <- cbind(py, sdCheck.py)
for(i in 1:length(keySoilVars)){
print(
ggplot(py, aes(x = py[,keySoilVars[i]], y = tha)) +
geom_point() +
stat_smooth() +
geom_vline(xintercept=summary(py[,keySoilVars[i]])[[2]], linetype="dashed") +
geom_vline(xintercept=summary(py[,keySoilVars[i]])[[5]], linetype="dashed") +
labs(title = keySoilVars[i], x= keySoilVars[i], y="Yield (t/ha)")
)
}
for(i in 1:length(keySoilVars)){
print(
ggplot(py, aes(x = py[,keySoilVars[i]], y = log10(tha))) +
geom_point() +
stat_smooth() +
#geom_vline(xintercept=summary(py[,keySoilVars[i]])[[2]], linetype="dashed") +
#geom_vline(xintercept=summary(py[,keySoilVars[i]])[[5]], linetype="dashed") +
labs(title = keySoilVars[i], x= keySoilVars[i], y="Yield (t/ha)")
)
}
py$cell <- tolower(py$cell)
aggCell <- py %>%
group_by(cell) %>%
summarize_each(funs(mean(., na.rm=T)), c(tha, ph, x.organic.carbon, x.total.nitrogen, calcium, magnesium)) %>%
as.data.frame()
for(i in 1:length(keySoilVars)){
print(
ggplot(aggCell, aes(x = aggCell[,keySoilVars[i]], y = tha)) +
geom_point() +
stat_smooth() +
#stat_smooth(method="lm", color="red")+
labs(title = keySoilVars[i], x= keySoilVars[i], y="Yield (t/ha)")
)
}
aggCell$ph2 <- aggCell$ph^2
theoryPh <- lm(tha ~ ph + ph2, data=aggCell)
aggCell$c2 <- aggCell$x.organic.carbon^2
theoryC <- lm(tha ~ x.organic.carbon + c2, data=aggCell)
summary(theoryC)
beta1 <- summary(theoryC)$coeff[2]
beta2 <- summary(theoryC)$coeff[3]
keyPoint <- (-beta1)/(2*beta2)
ggplot(aggCell, aes(x = x.organic.carbon, y = tha)) +
geom_point() +
#stat_smooth() +
stat_function(fun=function(x) log(x)) +
geom_vline(xintercept=keyPoint) +
#stat_smooth(method="lm", color="red")+
labs(title = "Carbon", x = "Carbon", y="Yield (t/ha)")
theoryCLog <- lm(log10(tha) ~ x.organic.carbon, data=subset(aggCell, aggCell$tha>1))
summary(theoryCLog)
beta1 <- summary(theoryC)$coeff[2]
#beta2 <- summary(theoryC)$coeff[3]
keyPoint <- (-beta1)/(2*beta2)
ggplot(aggCell, aes(x = x.organic.carbon, y = tha)) +
geom_point() +
#stat_smooth() +
stat_function(fun=function(x) log(x)) +
geom_vline(xintercept=keyPoint) +
#stat_smooth(method="lm", color="red")+
labs(title = "Carbon", x = "Carbon", y="Yield (t/ha)")
ggplot(data.frame(x = c(-4, 4)), aes(x = x)) +
stat_function(fun = function(x) x - x^2)
ggplot(data.frame(x = c(-4, 4)), aes(x = x)) +
stat_function(fun = function(x) log(x))
pairedWetDir <- normalizePath(file.path("..", "..", "OAF Soil Lab Folder", "Projects", "rw_shs_16b_paired_climbing", "3_wet_chem"))
pairedWet <- read.csv(file=paste(pairedWetDir, "wet_chem.csv", sep = "/"))
pSoilIdDir <- normalizePath(file.path("..", "..", "OAF Soil Lab Folder", "Projects", "rw_shs_16b_paired_climbing", "5_merged"))
pSoilIds <- read.csv(file=paste(pSoilIdDir, "database.csv", sep = "/"))
pairedWet <- pairedWet %>%
mutate(
Field.Name = tolower(Field.Name)
) %>%
rename(
LAB.SSN = Field.Name
) %>%
filter(LAB.SSN!="") %>%
left_join(., pSoilIds, by="LAB.SSN") %>%
rename(
ssn = LAB.SSN
) %>%
left_join(., py[,c("tha", "ssn")], by="ssn")
names(pairedWet) <- tolower(names(pairedWet))
# pairedWet$ssn[is.na(pairedWet$tha)]
#
# pairedWet$ssn[!pairedWet$ssn %in% py$ssn]
# sort(py$ssn[!py$ssn %in% pairedWet$ssn])
#py$ssn[grep("35", py$ssn)]
for(i in 1:length(keySoilVars)){
print(
ggplot(pairedWet, aes(x = pairedWet[,keySoilVars[i]], y = tha)) +
geom_point() +
stat_smooth() +
#stat_smooth(method="lm", color="red")+
labs(title = keySoilVars[i], x= keySoilVars[i], y="Yield (t/ha)")
)
}
pairedWet$c2 <- pairedWet$x.organic.carbon^2
theoryWC <- lm(tha ~ x.organic.carbon + c2, data=pairedWet)
#summary(theoryWC)
beta1 <- summary(theoryWC)$coeff[2]
beta2 <- summary(theoryWC)$coeff[3]
keyPoint <- (-beta1)/(2*beta2)
ggplot(pairedWet, aes(x = x.organic.carbon, y = tha)) +
geom_point() +
#stat_smooth() +
stat_function(fun=function(x) log(x)) +
geom_vline(xintercept=keyPoint) +
#stat_smooth(method="lm", color="red")+
labs(title = "Carbon", x = "Carbon", y="Yield (t/ha)")
yQuartiles <- function(yVar, xVar, df){
applyCuts = cut(df[,xVar], breaks=quantile(df[,xVar],c(0.25, 0.5, 0.75, 1),type=1, na.rm=T))
tab = tapply(df[,yVar], applyCuts, mean)
#diff = tab[[4]] - tab[[1]]
return(tab)
}
yQChange <- function(tab, start, end){ #start and end are the indicies
diff = tab[[end]]-tab[[start]]
return(diff)
}
qTab <- do.call(rbind, lapply(keySoilVars, function(x){
yQuartiles("tha", x, py)
}))
qTab <- as.data.frame(qTab)
names(qTab) <- c("q25to50","q50to75","q75to100")
qTab <- as.data.frame(sapply(qTab, function(x){round(x,2)}))
qTab <- cbind(qTab,
diff25to50 = apply(qTab, 1, function(x){
yQChange(x,1,2)}),
diff50to75 = apply(qTab, 1, function(x){
yQChange(x,2,3)}))
library(scales)
# add revenue
marketValueT <- 500
numFarmersRw <- 164500/4
qTab$revenueA <- dollar(qTab$diff25to50 * marketValueT)
qTab$revenueB <- dollar(qTab$diff50to75 * marketValueT)
write.csv(qTab, file="output/quartileCalc.csv")
minThresh <- function(xVar, yVar, per.thold, thold, FarmerCount, marketValue, df){
# figure out where the threshold is in terms of percentile of xVar
# calculate value of moving farmers below that percentile above that perentile in terms of yield gain
dist <- ecdf(df[,xVar])
perce <- dist(thold)
# amount above thold
inClear <- 1-perce
remainToMove <- ifelse(per.thold-inClear>0, per.thold - inClear, 0)
remainToMoveFarmers <- FarmerCount*remainToMove
startingPointX <- quantile(df[,xVar], c(perce - remainToMove), type=1, na.rm = T)[[1]]
# yield value above threshold
above <- mean(df[,yVar][df[,xVar]>thold], na.rm = T) #this is the average for all above threshold
#distance between farmers yield value and threshold yield value for farmers below threshold and within the percentile we want to move up.
remaining <-subset(df, df[,xVar]>=startingPointX & df[,xVar]<=thold)
bump <- above - remaining[,yVar]
marketValuetha <- marketValue*1000
#average value add
res <-mean(bump, na.rm = T) * remainToMoveFarmers * marketValuetha
res <- paste(format(round(res / 1e6, 2), trim = TRUE), "M")
return(res)
}
progImpactpH <- minThresh("ph", "tha", 0.75, 5.8, 282228, 0.50, py)
progImpactN <- minThresh("x.total.nitrogen", "tha", 0.75, 0.1, 282228, 0.50, py)
progImpactC <- minThresh("x.organic.carbon", "tha", 0.75, 2, 282228, 0.50, py)
progImpactCa <- minThresh("calcium", "tha", 0.75, 1056, 282228, 0.50, py)
progImpactMg <- minThresh("magnesium", "tha", 0.75, 148, 282228, 0.50, py)
progObj <- ls()[grep("progImpact", ls())]
progImpTab <- do.call(rbind, lapply(progObj, function(x){get(x)}))
progImpTab <- data.frame(var = progObj, value = progImpTab)
write.csv(progImpTab, file=paste("output/", "rwandaThresholdTab.csv", sep=""), row.names = F)
#### set up
## clear environment and console
rm(list = ls())
cat("\014")
## set up some global options
# always set stringsAsFactors = F when loading data
options(stringsAsFactors=FALSE)
# show the code
knitr::opts_chunk$set(echo = TRUE)
# define all knitr tables to be html format
options(knitr.table.format = 'html')
# change code chunk default to not show warnings or messages
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
libs <- c("dplyr", "reshape2", "knitr", "ggplot2", "tibble", "readxl",
"MASS", "gridExtra", "cowplot", "robustbase", "car", "RStata", "foreign",
"tidyr", "readxl", "readxl")
lapply(libs, require, character.only = T, quietly = T, warn.conflicts = F)
#### define helpful functions
# define function to adjust table widths
html_table_width <- function(kable_output, width) {
width_html <- paste0(paste0('<col width="', width, '">'), collapse = "\n")
sub("<table>", paste0("<table>\n", width_html), kable_output)
}
options("RStata.StataVersion" = 12)
options("RStata.StataPath" = "/Applications/Stata/StataSE.app/Contents/MacOS/stata-se")
dataDir <- normalizePath(file.path("..", "..", "data"))
soilDir <- normalizePath(file.path("..", "..", "OAF Soil Lab Folder", "Projects", "ke_shs_maize_paired"))
forceUpdateAll <- FALSE
source("../oaflib/commcareExport.R")
py <- getFormData("harvest", "Harvest Soil Sampling 2016", "Soil Sampling 2016", forceUpdate = forceUpdateAll)
#write.csv(py, file="rawCcYpData.csv", row.names=F)
#names(bean)[grep("soil",names(bean))]
#names(bean)[grep("id",names(bean))]
#table(bean$soil_code, useNA = 'ifany')
pairedSoilDir <- normalizePath(file.path("..", "..", "OAF Soil Lab Folder", "Projects", "ke_shs_maize_paired", "4_predicted", "other_summaries"))
pairedSoil <- read.csv(file=paste(pairedSoilDir, "combined-predictions-including-bad-ones.csv", sep = "/"))
pSoilIdDir <- normalizePath(file.path("..", "..", "OAF Soil Lab Folder", "Projects", "ke_shs_maize_paired", "5_merged"))
pSoilIds <- read_excel(paste(pSoilIdDir, "database.xlsx", sep = "/"))
yd <- getFormData("harvest", "Harvest Survey 2016", "Maize Dry Weight", forceUpdate = forceUpdateAll)
dat <- yd %>%
setNames(tolower(names(.))) %>%
dplyr::select(contains("bag"), contains("cmid"), contains("oafid")) %>%
rename(
separate = `did the farmer keep maize separate in bags ?`,
added = `was anything added or removed from the harvest bag?`,
bagA.oaf = `oaf farmer, oaf plot dry weight bag a`,
bagB.oaf = `oaf farmer, oaf plot dry weight bag b`,
bagA.nonoaf = `oaf farmer, non oaf plot dry weight bag a`,
bagB.nonoaf = `oaf farmer, non oaf plot dry weight bag b`,
bagA.control = `non oaf farmer dry weight bag a`,
bagB.control = `non oaf farmer dry weight bag b`,
cmid = `#form/identifier/cmid`,
oafid = `#form/identifier/oafid`
) %>%
gather(key, value, -c(cmid, oafid, separate, added)) %>%
separate(key, c("var", "type"), sep="\\.") %>%
filter(!is.na(value)) %>%
mutate(value = ifelse(value<0, NA, value)) %>%
group_by(cmid, type) %>%
summarize(bagYield = sum(value, na.r=T)) %>%
arrange(cmid)
harvestBox <- getFormData("harvest", "Harvest Survey 2016", "Maize Harvest Box", forceUpdate = forceUpdateAll)
hb <- harvestBox %>%
setNames(tolower(names(.))) %>%
dplyr::select(contains("box A"), contains("box B"), contains("cmid"), contains("identifier/oaf")) %>%
rename(
width.BoxA.oaf = `width of oaf farmer, oaf plot box a`,
length.BoxA.oaf = `length of oaf farmer, oaf plot box a`,
width.BoxA.nonoaf = `width of oaf farmer, non oaf plot box a`,
length.BoxA.nonoaf = `length of oaf farmer, non oaf plot box a`,
width.BoxA.control = `width of non oaf farmer plot box a`,
length.BoxA.control = `length of non oaf farmer plot box a`,
width.BoxB.oaf = `width of oaf farmer, oaf plot box b`,
length.BoxB.oaf = `length of oaf farmer, oaf plot box b`,
width.BoxB.nonoaf = `width of oaf farmer, non oaf plot box b`,
length.BoxB.nonoaf = `length of oaf farmer, non oaf plot box b`,
width.BoxB.control = `width of non oaf farmer plot box b`,
length.BoxB.control = `length of non oaf farmer plot box b`,
cmid = `#form/identifier/cmid`,
type = `#form/identifier/oaf`,
oafid = `#form/identifier/oafid`
) %>%
dplyr::select(-contains("group")) %>%
gather(key, value, -c(cmid, oafid, type)) %>%
filter(!is.na(value) & !is.na(cmid)) %>%
separate(key, c("measure", "box", "type2"), sep="\\.") %>%
group_by(cmid, box, type2) %>%
summarize(area = prod(value, na.rm=T)) %>%
group_by(cmid, type2) %>%
summarise(area = sum(area, na.rm=T)) %>%
rename(type = type2) %>%
mutate(area = ifelse(area>80, 80, area))
#combine dat and hb to have yield and harvest box size
dat <- left_join(dat, hb, by=c("cmid", "type"))
psi <- pSoilIds %>%
setNames(tolower(names(.))) %>%
setNames(gsub("identifier.|info.", "i.", names(.))) %>%
mutate_each(funs(tolower), i.district, i.sublocation) %>%
rename(ssn = plot_i.mation.bar_code) %>%
mutate(
ssn = gsub("_", "", ssn),
ssn = gsub(" ", "", ssn),
ssnDups = duplicated(ssn) | duplicated(.[nrow(.):1, "ssn"])[nrow(.):1]
) %>% as.data.frame()
table(psi$ssnDups)
psi$ssn[psi$ssnDups==T]
pairedSoil <- pairedSoil %>%
setNames(tolower(names(.))) %>%
mutate(
ssn = gsub("_", "", ssn),
ssn = gsub("oafoaf", "oaf", ssn)
)
table(psi$ssn %in% pairedSoil$ssn) # FALSE  TRUE  41   703
table(pairedSoil$ssn %in% psi$ssn) # FALSE  TRUE  27   703
psi$ssn[!psi$ssn %in% pairedSoil$ssn]
pairedSoil$ssn[!pairedSoil$ssn %in% psi$ssn]
pairedSoil <- left_join(pairedSoil, psi, by="ssn") %>%
dplyr::select(-x) %>%
rename(oaf.indicator = oaf) %>%
setNames(gsub("i\\.", "", names(.)))
py <- py %>%
rename(
ssn = `Bar code scan`
) %>%
setNames(tolower(names(.))) %>%
filter(!is.na(ssn)) %>%
mutate(ssn = gsub(" ", "", ssn),
ssn = gsub("_", "", ssn)) %>%
mutate(idDups = duplicated(ssn) | duplicated(.[nrow(.):1, "ssn"])[nrow(.):1])
pyCheck <- py %>%
filter(idDups==TRUE) %>%
arrange(ssn) %>%
dplyr::select(district, sublocation, ssn)
pyCheck
#vector of duplicated ids in the bean data
idComps <- unique(pyCheck$ssn[pyCheck$idDups==TRUE])
pairedSoil %>%
filter(ssn %in% idComps) %>%
arrange(ssn) %>%
dplyr::select(district, sublocation, ssn)
py <- py %>%
filter(idDups==FALSE)
py <- py %>%
inner_join(., pairedSoil, by="ssn") %>%
#rename(cmid = `#form/identifier/cmid`) %>%
as.data.frame()
table(py$cmid %in% dat$cmid)
sample(py$cmid[!py$cmid %in% dat$cmid],10)
table(dat$cmid %in% py$cmid)
dat <- as.data.frame(dat)
py <- merge(py, dat, by="cmid")
#yr <- py[,names(py) %in% respVar]
py$tha <- (py$bagYield/py$area) * 10
soilVars <- names(py)[which(names(py)=="potassium"):which(names(py)=="x.total.nitrogen")]
keySoilVars <- c("ph", "x.organic.carbon", "x.total.nitrogen", "calcium", "magnesium")
check.3sd <- function(x) {
x = ifelse(is.infinite(x), NA, x)
mean = mean(x, na.rm=T)
sd = sd(x, na.rm=T)
mark = ifelse(x>(mean + (3*sd)) |
x<(mean - (3*sd)), NA, x)
return(mark)
}
sdSoilVals.py <- py %>%
dplyr::select(one_of(soilVars))
sdCheck.py <- as.data.frame(apply(sdSoilVals.py, 2, function(x){
return(check.3sd(x))
}))
names(py)[which(names(py)=="potassium"):which(names(py)=="x.total.nitrogen")] <- paste0(names(py)[which(names(py)=="potassium"):which(names(py)=="x.total.nitrogen")], ".raw")
py <- cbind(py, sdCheck.py)
for(i in 1:length(keySoilVars)){
print(
ggplot(py, aes(x = py[,keySoilVars[i]], y = tha)) +
geom_point() +
stat_smooth() +
geom_vline(xintercept=summary(py[,keySoilVars[i]])[[2]], linetype="dashed") +
geom_vline(xintercept=summary(py[,keySoilVars[i]])[[5]], linetype="dashed") +
labs(title = keySoilVars[i], x= keySoilVars[i], y="Yield (t/ha)")
)
}
yQuartiles <- function(yVar, xVar, df){
applyCuts = cut(df[,xVar], breaks=quantile(df[,xVar],c(0.25, 0.5, 0.75, 1),type=1, na.rm=T))
tab = tapply(df[,yVar], applyCuts, function(x){mean(x, na.rm=T)})
#diff = tab[[4]] - tab[[1]]
return(tab)
}
yQChange <- function(tab, start, end){ #start and end are the indicies
diff = tab[[end]]-tab[[start]]
return(diff)
}
qTab <- do.call(rbind, lapply(keySoilVars, function(x){
yQuartiles("tha", x, py)
}))
qTab <- as.data.frame(qTab)
names(qTab) <- c("q25to50","q50to75","q75to100")
qTab <- as.data.frame(sapply(qTab, function(x){round(x,2)}))
qTab <- cbind(qTab,
diff25to50 = apply(qTab, 1, function(x){
yQChange(x,1,2)}),
diff50to75 = apply(qTab, 1, function(x){
yQChange(x,2,3)}))
rownames(qTab) <- keySoilVars
library(scales)
# add revenue
marketValueT <- 340
numFarmersKe <- 217000/4
qTab$revenueA <- dollar(qTab$diff25to50 * marketValueT)
qTab$revenueB <- dollar(qTab$diff50to75 * marketValueT)
write.csv(qTab, file="output/quartileCalc.csv")
minThresh <- function(xVar, yVar, per.thold, thold, FarmerCount, marketValue, df){
# figure out where the threshold is in terms of percentile of xVar
# calculate value of moving farmers below that percentile above that perentile in terms of yield gain
dist <- ecdf(df[,xVar])
perce <- dist(thold)
# amount above thold
inClear <- 1-perce
remainToMove <- ifelse(per.thold-inClear>0, per.thold - inClear, 0)
remainToMoveFarmers <- FarmerCount*remainToMove
startingPointX <- quantile(df[,xVar], c(perce - remainToMove), type=1, na.rm = T)[[1]]
# yield value above threshold
above <- mean(df[,yVar][df[,xVar]>thold], na.rm = T) #this is the average for all above threshold
#distance between farmers yield value and threshold yield value for farmers below threshold and within the percentile we want to move up.
remaining <-subset(df, df[,xVar]>=startingPointX & df[,xVar]<=thold)
bump <- above - remaining[,yVar]
marketValuetha <- marketValue*1000
#average value add
res <- mean(bump, na.rm = T) * remainToMoveFarmers * marketValuetha
res <- paste(format(round(res / 1e6, 2), trim = TRUE), "M")
return(res)
}
progImpactpH <- minThresh("ph", "tha", 0.75, 5.8, 217000, 0.34, py)
progImpactN <- minThresh("x.total.nitrogen", "tha", 0.75, 0.1, 217000, 0.34, py)
progImpactC <- minThresh("x.organic.carbon", "tha", 0.75, 2, 217000, 0.34, py)
progImpactCa <- minThresh("calcium", "tha", 0.75, 1056, 217000, 0.34, py)
progImpactMg <- minThresh("magnesium", "tha", 0.75, 148, 217000, 0.34, py)
progObj <- ls()[grep("progImpact", ls())]
progImpTab <- do.call(rbind, lapply(progObj, function(x){get(x)}))
progImpTab <- data.frame(var = progObj, value = progImpTab)
write.csv(progImpTab, file=paste("output/", "rwandaThresholdTab.csv", sep=""), row.names = F)
progImpTab
